// backend/src/db.ts
import { MongoClient, Db, Collection } from 'mongodb';
import { GameConfig, Player, Players, ScoringConfig } from './types'; // Adjust imports as types evolve
import { PointData } from './spatialHashGrid';

// Define interfaces for DB documents
export interface GameDocument {
    _id: string; // Use gameId as the MongoDB _id
    boardConfig: GameConfig;
    scoringConfig: ScoringConfig;
    // Store player IDs; full player data might be in a separate collection
    playerIds: string[];
    gameOver: boolean;
    createdAt: Date;
    updatedAt: Date;
    // Consider storing mineReveals/pendingReveals here if they don't grow excessively large
    // mineReveals?: MineReveal[];
    // pendingReveals?: { row: number; col: number }[];
}

export interface PlayerDocument extends Omit<Player, 'status' | 'lockedUntil'> { // Omit transient fields
    _id: string; // Use playerId as the MongoDB _id
    gameId: string; // To associate player with a game
    // Add lastSeen or other persistent fields if needed
}

export interface BoardChunkDocument {
   // _id will be auto-generated by Mongo or use a compound key { gameId, chunkX, chunkY }
   gameId: string;
   chunkX: number;
   chunkY: number;
   cells: { [cellKey: string]: PointData }; // e.g., { "x,y": { revealed: true } }
   updatedAt: Date;
}

// --- Connection Setup ---
const MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017';
const DB_NAME = process.env.DB_NAME || 'minesweeper_infinite';

let client: MongoClient;
let db: Db;

// Collections (initialize after connection)
let gamesCollection: Collection<GameDocument>;
let playersCollection: Collection<PlayerDocument>;
let boardChunksCollection: Collection<BoardChunkDocument>;


export async function connectToDatabase(): Promise<void> {
    if (db) {
        console.log('Already connected to MongoDB.');
        return;
    }
    try {
        client = new MongoClient(MONGODB_URI);
        await client.connect();
        db = client.db(DB_NAME);

        // Initialize collections
        gamesCollection = db.collection<GameDocument>('games');
        playersCollection = db.collection<PlayerDocument>('players');
        boardChunksCollection = db.collection<BoardChunkDocument>('boardChunks');

        // --- Create Indexes ---
        // Index for finding games by ID
        await gamesCollection.createIndex({ _id: 1 });

        // Index for finding players by ID
        await playersCollection.createIndex({ _id: 1 });
        // Index for finding players belonging to a specific game
        await playersCollection.createIndex({ gameId: 1 });

        // Compound unique index for board chunks to enable upserts and fast lookups
        await boardChunksCollection.createIndex({ gameId: 1, chunkX: 1, chunkY: 1 }, { unique: true });
        // Index potentially useful for cleanup tasks (e.g., finding old chunks)
        await boardChunksCollection.createIndex({ updatedAt: 1 });

        console.log(`Successfully connected to database: ${db.databaseName}`);
    } catch (error) {
        console.error('Error connecting to MongoDB:', error);
        // Consider a more robust error handling/retry mechanism for production
        process.exit(1); // Exit if DB connection fails on startup
    }
}

export async function disconnectFromDatabase(): Promise<void> {
    if (client) {
        await client.close();
        console.log('Disconnected from MongoDB.');
    }
}

// --- Collection Getters ---

export function getGamesCollection(): Collection<GameDocument> {
    if (!gamesCollection) throw new Error("Database not connected or games collection not initialized.");
    return gamesCollection;
}

export function getPlayersCollection(): Collection<PlayerDocument> {
    if (!playersCollection) throw new Error("Database not connected or players collection not initialized.");
    return playersCollection;
}

export function getBoardChunksCollection(): Collection<BoardChunkDocument> {
    if (!boardChunksCollection) throw new Error("Database not connected or boardChunks collection not initialized.");
    return boardChunksCollection;
}

// --- Database Interaction Functions (Examples) ---

/**
 * Saves or updates a board chunk document using upsert.
 */
export async function saveBoardChunk(chunkData: Omit<BoardChunkDocument, 'updatedAt'>): Promise<void> {
    const collection = getBoardChunksCollection();
    const timestamp = new Date();
    await collection.updateOne(
        // Filter to find the specific chunk
        { gameId: chunkData.gameId, chunkX: chunkData.chunkX, chunkY: chunkData.chunkY },
        // Update operation
        {
            $set: {
                cells: chunkData.cells,
                updatedAt: timestamp
            },
            $setOnInsert: { // Set these only if inserting a new document
                 gameId: chunkData.gameId,
                 chunkX: chunkData.chunkX,
                 chunkY: chunkData.chunkY
            }
        },
        // Options: upsert = true
        { upsert: true }
    );
}

/**
 * Loads multiple board chunks for a given game based on chunk coordinates.
 */
export async function loadBoardChunks(gameId: string, chunkCoords: { chunkX: number; chunkY: number }[]): Promise<BoardChunkDocument[]> {
     if (chunkCoords.length === 0) {
         return []; // No coordinates provided, return empty array
     }
     const collection = getBoardChunksCollection();
     // Construct the $or query dynamically based on the provided coordinates
     const query = {
         gameId: gameId,
         $or: chunkCoords.map(coords => ({ chunkX: coords.chunkX, chunkY: coords.chunkY }))
     };
     return collection.find(query).toArray();
}

/**
 * Saves a new game document.
 */
export async function saveNewGame(gameDoc: Omit<GameDocument, 'createdAt' | 'updatedAt'>): Promise<void> {
    const collection = getGamesCollection();
    const timestamp = new Date();
    await collection.insertOne({
        ...gameDoc,
        createdAt: timestamp,
        updatedAt: timestamp
    });
}

/**
 * Loads a game document by its ID.
 */
export async function loadGame(gameId: string): Promise<GameDocument | null> {
    const collection = getGamesCollection();
    return collection.findOne({ _id: gameId });
}

// Add more functions as needed for saving/loading players, updating game state (e.g., gameOver), etc.
