// backend/src/db.ts
import { MongoClient, Db, Collection } from 'mongodb';
// Import PointData, LeaderboardCategory, LeaderboardMetric, LeaderboardEntry from domain/types
import { GameConfig, Player, Players, ScoringConfig, GameRepository, GameState, Cell, PointData, LeaderboardCategory, LeaderboardMetric, LeaderboardEntry } from '../../domain/types'; 

// Define interfaces for DB documents
export interface GameDocument {
    _id: string; // Use gameId as the MongoDB _id
    boardConfig: GameConfig;
    scoringConfig: ScoringConfig;
    // Store player IDs; full player data might be in a separate collection
    playerIds: string[];
    gameOver: boolean;
    createdAt: Date;
    updatedAt: Date;
    // Consider storing mineReveals/pendingReveals here if they don't grow excessively large
    // mineReveals?: MineReveal[];
    // pendingReveals?: { row: number; col: number }[];
}

export interface PlayerDocument extends Omit<Player, 'status' | 'lockedUntil'> { // Omit transient fields
    _id: string; // Use playerId as the MongoDB _id
    gameId: string; // To associate player with a game
    // Add lastSeen or other persistent fields if needed
}

export interface BoardChunkDocument {
   // _id will be auto-generated by Mongo or use a compound key { gameId, chunkX, chunkY }
   gameId: string;
   chunkX: number;
   chunkY: number;
   cells: { [cellKey: string]: PointData }; // Use PointData from types.ts
   updatedAt: Date;
}

// Define interface for leaderboard document
export interface LeaderboardDocument {
    _id: string; // Combined ID of category_metric (e.g. "all_time_highest_score")
    category: LeaderboardCategory;
    metric: LeaderboardMetric;
    entries: Array<LeaderboardEntry>;
    updatedAt: Date;
}

// --- Connection Setup ---
const MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017';
const DB_NAME = process.env.DB_NAME || 'minesweeper_infinite';

let client: MongoClient;
let db: Db;

// Collections (initialize after connection)
let gamesCollection: Collection<GameDocument>;
let playersCollection: Collection<PlayerDocument>;
let boardChunksCollection: Collection<BoardChunkDocument>;
let leaderboardsCollection: Collection<LeaderboardDocument>;

export async function connectToDatabase(): Promise<void> {
    if (db) {
        console.log('Already connected to MongoDB.');
        return;
    }
    try {
        client = new MongoClient(MONGODB_URI);
        await client.connect();
        db = client.db(DB_NAME);

        console.log(`Connected to MongoDB at ${MONGODB_URI}`);
        console.log(`Using database: ${DB_NAME}`); 
        // Initialize collections
        gamesCollection = db.collection<GameDocument>('games');
        playersCollection = db.collection<PlayerDocument>('players');
        boardChunksCollection = db.collection<BoardChunkDocument>('boardChunks');
        leaderboardsCollection = db.collection<LeaderboardDocument>('leaderboards');

        // --- Create Indexes ---
        // Index for finding games by ID
        await gamesCollection.createIndex({ _id: 1 });

        // Index for finding players by ID
        await playersCollection.createIndex({ _id: 1 });
        // Index for finding players belonging to a specific game
        await playersCollection.createIndex({ gameId: 1 });

        // Compound unique index for board chunks to enable upserts and fast lookups
        await boardChunksCollection.createIndex({ gameId: 1, chunkX: 1, chunkY: 1 }, { unique: true });
        // Index potentially useful for cleanup tasks (e.g., finding old chunks)
        await boardChunksCollection.createIndex({ updatedAt: 1 });

        // Indexes for leaderboards
        await leaderboardsCollection.createIndex({ _id: 1 }); // Primary key index
        await leaderboardsCollection.createIndex({ category: 1, metric: 1 }); // For querying by category and metric
        await leaderboardsCollection.createIndex({ updatedAt: 1 }); // For time-based operations (daily/weekly boards)

        console.log(`Successfully connected to database: ${db.databaseName}`);
    } catch (error) {
        console.error('Error connecting to MongoDB:', error);
        // Consider a more robust error handling/retry mechanism for production
        process.exit(1); // Exit if DB connection fails on startup
    }
}

export async function disconnectFromDatabase(): Promise<void> {
    if (client) {
        await client.close();
        console.log('Disconnected from MongoDB.');
    }
}

// --- Collection Getters ---

export function getGamesCollection(): Collection<GameDocument> {
    if (!gamesCollection) throw new Error("Database not connected or games collection not initialized.");
    return gamesCollection;
}

export function getPlayersCollection(): Collection<PlayerDocument> {
    if (!playersCollection) throw new Error("Database not connected or players collection not initialized.");
    return playersCollection;
}

export function getBoardChunksCollection(): Collection<BoardChunkDocument> {
    if (!boardChunksCollection) throw new Error("Database not connected or boardChunks collection not initialized.");
    return boardChunksCollection;
}

export function getLeaderboardsCollection(): Collection<LeaderboardDocument> {
    if (!leaderboardsCollection) throw new Error("Database not connected or leaderboards collection not initialized.");
    return leaderboardsCollection;
}

// --- MongoDB Implementation of GameRepository ---

export class MongoGameRepository implements GameRepository {
    private gamesCollection: Collection<GameDocument>;
    private boardChunksCollection: Collection<BoardChunkDocument>;

    constructor() {
        // Ensure collections are initialized before creating repository instance
        this.gamesCollection = getGamesCollection();
        this.boardChunksCollection = getBoardChunksCollection();
    }

    /**
     * Finds and retrieves a game's metadata by its ID.
     * Excludes detailed board/chunk data for efficiency.
     */
    async findGameById(gameId: string): Promise<Partial<GameState> | null> {
        const gameDoc = await this.gamesCollection.findOne({ _id: gameId });
        if (!gameDoc) {
            return null;
        }

        // TODO: Load associated players if needed, or handle player data separately
        // For now, just returning the core game metadata
        const gameState: Partial<GameState> = {
            gameId: gameDoc._id,
            boardConfig: gameDoc.boardConfig,
            scoringConfig: gameDoc.scoringConfig,
            players: {}, // Placeholder - Player loading logic needed
            mineReveals: [], // Placeholder - Persistence needed
            pendingReveals: [], // Placeholder - Persistence needed
            gameOver: gameDoc.gameOver,
            // board/spatialGrid are loaded separately via findChunk
        };
        return gameState;
    }

    /**
     * Saves the core metadata of a game state (upsert).
     */
    async saveGame(gameState: Partial<GameState>): Promise<void> {
        if (!gameState.gameId) {
            throw new Error("Cannot save game state without a gameId.");
        }

        const timestamp = new Date();
        // Prepare the document, excluding board/grid state and potentially large/transient fields
        const gameDocUpdate: Partial<GameDocument> = {};
        if (gameState.boardConfig) gameDocUpdate.boardConfig = gameState.boardConfig;
        if (gameState.scoringConfig) gameDocUpdate.scoringConfig = gameState.scoringConfig;
        if (gameState.players) gameDocUpdate.playerIds = Object.keys(gameState.players);
        if (gameState.gameOver !== undefined) gameDocUpdate.gameOver = gameState.gameOver;
        // Add other fields like winner, mineReveals, pendingReveals if they should be persisted in the main doc
        
        gameDocUpdate.updatedAt = timestamp;

        await this.gamesCollection.updateOne(
            { _id: gameState.gameId },
            {
                $set: gameDocUpdate, 
                $setOnInsert: { createdAt: timestamp, _id: gameState.gameId } // Ensure _id and createdAt on insert
            },
            { upsert: true }
        );
    }

    /**
     * Finds and retrieves a specific chunk of the spatial grid.
     * Returns data compatible with SpatialHashGrid<PointData>.
     */
    async findChunk(gameId: string, chunkId: string): Promise<Map<string, PointData> | null> {
        // Assuming chunkId is "x_y"
        const parts = chunkId.split('_');
        if (parts.length !== 2) {
             console.error(`Invalid chunkId format on find: ${chunkId}`);
             return null;
        }
        const chunkX = parseInt(parts[0], 10);
        const chunkY = parseInt(parts[1], 10);
        
        if (isNaN(chunkX) || isNaN(chunkY)) {
            console.error(`Invalid chunk coordinates parsed from chunkId: ${chunkId}`);
            return null;
        }

        const chunkDoc = await this.boardChunksCollection.findOne({ gameId, chunkX, chunkY });

        if (!chunkDoc || !chunkDoc.cells) {
            return null;
        }

        // Convert the stored object back into a Map<string, PointData>
        const cellMap = new Map<string, PointData>();
        for (const key in chunkDoc.cells) {
            // Key should be "x,y"
            cellMap.set(key, chunkDoc.cells[key]); // Already stored as PointData
        }
        return cellMap;
    }

    /**
     * Saves or updates a specific chunk of the spatial grid.
     * Expects data compatible with SpatialHashGrid<PointData>.
     */
    async saveChunk(gameId: string, chunkId: string, chunkData: Map<string, PointData>): Promise<void> {
        // Assuming chunkId is "x_y"
        const parts = chunkId.split('_');
         if (parts.length !== 2) {
             throw new Error(`Invalid chunkId format for saving: ${chunkId}`);
        }
        const chunkX = parseInt(parts[0], 10);
        const chunkY = parseInt(parts[1], 10);

        if (isNaN(chunkX) || isNaN(chunkY)) {
            throw new Error(`Invalid chunk coordinates parsed from chunkId for saving: ${chunkId}`);
        }

        // Convert Map<string, PointData> to a plain object for MongoDB storage
        const cellsObject: { [key: string]: PointData } = {};
        chunkData.forEach((value, key) => {
            // Key should be "x,y"
            cellsObject[key] = value;
        });

        const timestamp = new Date();
        await this.boardChunksCollection.updateOne(
            { gameId, chunkX, chunkY },
            {
                $set: {
                    cells: cellsObject,
                    updatedAt: timestamp
                },
                $setOnInsert: { gameId, chunkX, chunkY } // Use the parsed coordinates
            },
            { upsert: true }
        );
    }

    // --- Potentially add methods for player persistence here ---
    // async savePlayer(player: Player): Promise<void> { ... }
    // async findPlayersByGame(gameId: string): Promise<Player[]> { ... }
}
